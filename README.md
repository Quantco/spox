# Steelix

[![CI](https://github.com/Quantco/steelix/actions/workflows/ci.yml/badge.svg)](https://github.com/Quantco/steelix/actions/workflows/ci.yml)
[![Documentation](https://img.shields.io/badge/docs-latest-success?style=plastic)](https://docs.dev.quantco.cloud/qc-github-artifacts/Quantco/steelix/latest/index.html)

Steelix is a library for constructing computational graphs following the [ONNX standard](https://github.com/onnx/onnx/).

Steelix enforces the strong type system of ONNX. Errors with respect to the ONNX specification are raised immediately, rather than at a later build step.

## Installation

Steelix is published on conda-forge and can be installed as expected:

```bash
mamba install steelix
```

## Introduction

### Arrows

The `Arrow` object is Steelix's most prominent abstraction.
It represents a lazy value (most commonly a `tensor`, but it also covers `map`, `optional` and `sequence` types) in the computational graph.
It can be visualised as an edge outgoing from a node whereas the node represents a function with `Arrow`s as inputs and outputs.

Given its lazy nature, an `Arrow` object does not have a concrete value, but it does have an explicit type and an optional shape which are propagated through operations.
For example, given `a: Arrow` and `b: Arrow`, `c: Arrow = add(a, b)` is the Arrow representing the sum of `a` and `b`.
The type and shape information of `c` is automatically derived from the input arrows following the ONNX specifications.
The `add` function is an _operator constructor_, which internally constructs an ONNX `Add` node and returns an Arrow representing its output.

`Arrow`s maintain the information about their ancestry and therefore contain all the information needed to later construct the computational graph.

#### Operator constructors

The ONNX specification differentiates between `inputs` and `attributes` which are provided to any given operation.
The former are lazy inputs to the operation while the latter are statically known parameters (e.g. weights).
Steelix's operator constructors make the same distinction.
Operator constructors expect `Arrow`s as `inputs` and eagerly computed values as `attributes`.
Constructor functions always output `Arrow`s.

Steelix provides constructor functions for all operations defined by the ONNX specification.
This includes the [`ai.onnx`](https://github.com/onnx/onnx/blob/main/docs/Operators.md) as well as the [`ai.onnx.ml`](https://github.com/onnx/onnx/blob/main/docs/Operators-ml.md) domain.

Constructors are autogenerated with the `src/generate.py` script based on the list of operator schemas provided by `onnx`. The modules with them may be imported from `steelix.opset.ai.onnx.*`, at a given version of the opset.

If a computational graph contains operations from different versions of the standard, Steelix will attempt to update all operations to the newest version observed in the graph.

### Graphs

The starting point to construction a computational graph are the source input arrows.
Since source inputs must be named in ONNX, it is strongly recommended to use the `steelix.arguments` or `steelix.arguments_dict` functions to construct these initial `Arrow`s.
For example, `arguments(**kwargs: Type) -> Tuple[Arrow, ...]` returns source `Arrow`s of the given `Type`s and of names the same as the keys.

To finish constructing an ONNX graph, one must also explicitly specify which `Arrow`s should be outputs of the graph.
To this end, use the `steelix.results` function. For example, `results(**kwargs: Arrow) -> Graph` returns a graph where results are the given Arrows, with the result names as in the keys.

Importantly, all names used as `argument` and `result` names must be unique. However, the same `Arrow` may be associated to more than one output name.

An `onnx.ModelProto` object may finally be build from a Steelix `Graph` using the `Graph.to_onnx_model` function.

### Running

Once you have constructed an `onnx.ModelProto`, refer to the ONNX documentation on how to process it further. For example, you may save it to a file with `onnx.save` or convert it to bytes via `.SerializeToString()`.

The resulting ONNX model may be executed using a runtime such as the reference [ONNX Runtime](https://onnxruntime.ai).

### Example usage

This example constructs a graph, taking floating point vectors `a`, `b`, `c`, and returning `r = a*b + c`.

```py
import numpy
import onnxruntime

from steelix import arguments, results, Tensor
import steelix.opset.ai.onnx.v17 as op

# Construct a Tensor type representing a (1D) vector of float32, of size N.
Vectorf32 = Tensor(numpy.float32, ('N',))

# a, b, c are all vectors and named the same in the graph
a, b, c = arguments(a=Vectorf32, b=Vectorf32, c=Vectorf32)

# p represents the Arrow equivalent to a * b
p = op.mul(a, b)
q = op.add(p, c)
# q = op.add(op.mul(a, b), c) works exactly the same

# Construct a Steelix graph with the result
graph = results(r=q)

# We leave Steelix-land and use ONNX Runtime to execute
session = onnxruntime.InferenceSession(graph.to_onnx_model().SerializeToString())
(result,) = session.run(None, {
	'a': numpy.array([1, 2, 3], dtype=numpy.float32),
	'b': numpy.array([2, 4, 1], dtype=numpy.float32),
	'c': numpy.array([1, 0, 1], dtype=numpy.float32)
})
# As expected, 3 = 1*2 + 1, etc.
assert (result == numpy.array([3, 8, 4])).all()
```
